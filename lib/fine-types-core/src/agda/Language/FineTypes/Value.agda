module Language.FineTypes.Value where

{-# FOREIGN AGDA2HS
-- !!! This Haskell module has been autogenerated by agda2hs.
-- !!! Do NOT change; change the original .agda file instead.
#-}

open import Haskell.Prelude hiding (_×_; _+_; Pair; case_of_)
open import Function.Base using (case_of_)
open import Language.FineTypes.Typ

isJust : ∀ {a : Set} → Maybe a → Bool
isJust (Just _) = True
isJust Nothing  = False

{-----------------------------------------------------------------------------
    Values index by a typ
------------------------------------------------------------------------------}
data Val : @0 Typ → Set where
  Unit : Val (Zero TUnit)
  Pair : ∀ {@0 A B : Typ} → Val A → Val B → Val (A × B)
  SumL : ∀ {@0 A B : Typ} → Val A → Val (A + B)
  SumR : ∀ {@0 A B : Typ} → Val B → Val (A + B)

{-# COMPILE AGDA2HS Val #-}

{-----------------------------------------------------------------------------
    Equality of Values at run-time
------------------------------------------------------------------------------}
data Eq-runtime : {@0 A B : Typ} → Val A → Val B → Set where
  eq-Unit : Eq-runtime Unit Unit
  eq-Pair
    : ∀ {@0 A1 A2 B1 B2 : Typ}
      {a1 : Val A1} {a2 : Val A2}
      {b1 : Val B1} {b2 : Val B2}
    → Eq-runtime a1 a2
    → Eq-runtime b1 b2
    → Eq-runtime (Pair a1 b1) (Pair a2 b2)
  eq-SumL
    : ∀ {@0 A1 A2 B1 B2 : Typ}
      {a1 : Val A1} {a2 : Val A2}
    → Eq-runtime a1 a2
    → Eq-runtime (SumL {A1} {B1} a1) (SumL {A2} {B2} a2)
  eq-SumR
    : ∀ {@0 A1 A2 B1 B2 : Typ}
      {b1 : Val B1} {b2 : Val B2}
    → Eq-runtime b1 b2
    → Eq-runtime (SumR {A1} {B1} b1) (SumR {A2} {B2} b2)

-- Lemma:
-- When to values are related by a run-time equality,
-- we can translate this into a function that maps one into the other.

{-----------------------------------------------------------------------------
    Type checking on the value level
------------------------------------------------------------------------------}
data Typchecks {@0 A : Typ} (va : Val A) (B : Typ) : Set where
  Checks
    : (vb : Val B)
    → Eq-runtime va vb
    → Typchecks va B

-- | Helper function that recurses into the typ and returns proof.
checkTyp
  : ∀ {@0 A : Typ} (v : Val A) (B : Typ)
  → Maybe (Typchecks v B)
checkTyp Unit (Zero TUnit) =
  Just (Checks Unit eq-Unit)
checkTyp (Pair x y) (Two Product2 X Y) =
  case (checkTyp x X) of λ
    { Nothing → Nothing
    ; (Just (Checks x' ex)) →
      case (checkTyp y Y) of λ
        { Nothing → Nothing
        ; (Just (Checks y' ey)) →
          Just (Checks (Pair x' y') (eq-Pair ex ey))
      }
    }
checkTyp (SumL x) (Two Sum2 X _) =
  case (checkTyp x X) of λ
    { Nothing → Nothing
    ; (Just (Checks x' ex)) →
      Just (Checks (SumL x') (eq-SumL ex))
    }
checkTyp (SumR y) (Two Sum2 _ Y) =
  case (checkTyp y Y) of λ
    { Nothing → Nothing
    ; (Just (Checks y' ey)) →
      Just (Checks (SumR y') (eq-SumR ey))
    }
checkTyp _ _ = Nothing

-- | Value-level check whether the typ matches.
hasTyp : ∀ {@0 A : Typ} → Val A → Typ → Bool
hasTyp Unit (Zero TUnit) = True
hasTyp (Pair x y) (Two Product2 tx ty) =
  hasTyp x tx && hasTyp y ty
hasTyp (SumL x) (Two Sum2 tx _) =
  hasTyp x tx
hasTyp (SumR y) (Two Sum2 _ ty) =
  hasTyp y ty
hasTyp _ _ =
  False

{-
test : (A : Typ) {@0 A = A₁ : Typ} (a : Val A₁)
  (w : Maybe (Typchecks a A)) →
  checkTyp a A ≡ w →
  (B : Typ) {@0 B = B₁ : Typ} (b : Val B₁) →
  (isJust w && isJust (checkTyp b B)) ≡
  isJust
  ((λ { Nothing → Nothing
      ; (Just (Checks x' ex))
          → case checkTyp b B of
            (λ { Nothing → Nothing
              ; (Just (Checks y' ey))
                  → Just (Checks (Pair x' y') (eq-Pair ex ey))
              })
      })
  w)
test = {!   !}
-}

{-
lemma-upgrade-hasTyp
  : ∀ {@0 A : Typ} (va : Val A) (B : Typ)
  → hasTyp va B ≡ isJust (checkTyp va B)
lemma-upgrade-hasTyp Unit (Zero TUnit) = refl
lemma-upgrade-hasTyp (Pair x y) (Two Product2 X Y)
    rewrite lemma-upgrade-hasTyp x X
    rewrite lemma-upgrade-hasTyp y Y
      with checkTyp y Y in eqY
...      | Nothing with checkTyp x X in eqX
...                | _ = ? 

-}
{-
postulate
  A : Set
  B : A → Set
  H : (x : A) → B x → Set

import Agda.Builtin.Sigma as S

test : (p : S.Σ A B) (w : A) → H w (S.snd p)
test = ?
-}

lemma-upgrade-hasTyp
  : ∀ {@0 A : Typ} (B : Typ) (va : Val A)
  → hasTyp va B ≡ isJust (checkTyp va B)
lemma-upgrade-hasTyp (Zero TUnit) Unit = refl
lemma-upgrade-hasTyp (Two Product2 A B) (Pair a b)
  rewrite lemma-upgrade-hasTyp A a
  rewrite lemma-upgrade-hasTyp B b
    with checkTyp a A
... | Nothing = refl
... | Just (Checks _ _) with checkTyp b B
...   | Nothing  = refl
...   | Just (Checks _ _) = refl
lemma-upgrade-hasTyp (Two Sum2 A _) (SumL a)
  rewrite lemma-upgrade-hasTyp A a
    with checkTyp a A
... | Nothing = refl
... | (Just (Checks x' ex)) = refl
lemma-upgrade-hasTyp (Two Sum2 _ B) (SumR b)
  rewrite lemma-upgrade-hasTyp B b
    with checkTyp b B
... | Nothing = refl
... | (Just (Checks y' ey)) = refl
lemma-upgrade-hasTyp (Zero TBool) Unit = refl
lemma-upgrade-hasTyp (Zero TNatural) Unit = refl
lemma-upgrade-hasTyp (One x B) Unit = refl
lemma-upgrade-hasTyp (Two x B B₁) Unit = refl
lemma-upgrade-hasTyp (Zero x) (Pair va va₁) = refl
lemma-upgrade-hasTyp (One x B) (Pair va va₁) = refl
lemma-upgrade-hasTyp (Two Sum2 B B₁) (Pair va va₁) = refl
lemma-upgrade-hasTyp (Zero x) (SumL va) = refl
lemma-upgrade-hasTyp (One x B) (SumL va) = refl
lemma-upgrade-hasTyp (Two Product2 B B₁) (SumL va) = refl
lemma-upgrade-hasTyp (Zero x) (SumR va) = refl
lemma-upgrade-hasTyp (One x B) (SumR va) = refl
lemma-upgrade-hasTyp (Two Product2 B B₁) (SumR va) = refl

lemma-good-hasTyp
  : ∀ (A : Typ) (a : Val A)
  → hasTyp a A ≡ True
lemma-good-hasTyp (Zero TUnit) Unit = refl
lemma-good-hasTyp (Two Product2 A B) (Pair a b)
  rewrite lemma-good-hasTyp A a
  rewrite lemma-good-hasTyp B b
  = refl
lemma-good-hasTyp (Two Sum2 A _) (SumL a) =
  lemma-good-hasTyp A a
lemma-good-hasTyp (Two Sum2 _ B) (SumR b) =
  lemma-good-hasTyp B b

{-# COMPILE AGDA2HS hasTyp #-}
   