module Language.FineTypes.Typ where

{-# FOREIGN AGDA2HS
-- !!! This Haskell module has been autogenerated by agda2hs.
-- !!! Do NOT change; change the original .agda file instead.
#-}

open import Haskell.Prelude
  using (String; List; True; False)
  renaming (_×_ to Pair)
open import Haskell.Law.Eq
open import Haskell.Prim.Eq

import Haskell.Prelude as Hs

ConstructorName = String
FieldName = String
TypName = String
VarName = String

{-# COMPILE AGDA2HS ConstructorName #-}
{-# COMPILE AGDA2HS FieldName #-}
{-# COMPILE AGDA2HS TypName #-}
{-# COMPILE AGDA2HS VarName #-}

{-----------------------------------------------------------------------------
    Haskell - Typ
------------------------------------------------------------------------------}
data TypConst : Set where
  Bool     : TypConst
  Bytes    : TypConst
  Integer  : TypConst
  Natural  : TypConst
  Text     : TypConst
  Rational : TypConst
  Unit     : TypConst

data OpOne : Set where
  Option   : OpOne
  Sequence : OpOne
  PowerSet : OpOne

data OpTwo : Set where
  Sum2     : OpTwo
  Product2 : OpTwo
  PartialFunction : OpTwo
  FiniteSupport   : OpTwo

data Constraint1 : Set where
  Braces : List Constraint1 → Constraint1
  Token  : String → Constraint1

Constraint = List Constraint1

data Typ : Set where
  Var  : TypName → Typ
  Zero : TypConst → Typ
  One  : OpOne → Typ → Typ
  Two  : OpTwo → Typ → Typ → Typ
  ProductN : List (Pair FieldName Typ) → Typ
  SumN : List (Pair ConstructorName Typ) → Typ
  Constrained : VarName → Typ → Constraint → Typ 

{-# COMPILE AGDA2HS TypConst #-}
{-# COMPILE AGDA2HS OpOne #-}
{-# COMPILE AGDA2HS OpTwo #-}
{-# COMPILE AGDA2HS Constraint1 #-}
{-# COMPILE AGDA2HS Constraint #-}
{-# COMPILE AGDA2HS Typ #-}

{-----------------------------------------------------------------------------
    Agda - Equality
------------------------------------------------------------------------------}
instance
  iTypConst : Eq TypConst
  iTypConst ._==_ Bool Bool = True
  iTypConst ._==_ Bytes Bytes = True
  iTypConst ._==_ Integer Integer = True
  iTypConst ._==_ Natural Natural = True
  iTypConst ._==_ Text Text = True
  iTypConst ._==_ Rational Rational = True
  iTypConst ._==_ Unit Unit = True
  iTypConst ._==_ _ _ = Hs.False

{-# COMPILE AGDA2HS iTypConst derive #-}

-- Created by automati case splitting C^c C^c
-- and automatic goal finding C^c C^a
instance
  iLawfulEqTypConst : IsLawfulEq TypConst

  iLawfulEqTypConst .isEquality Bool Bool = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Bool Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bool Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bool Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bool Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bool Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bool Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Bytes = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Bytes Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Bytes Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Integer = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Integer Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Integer Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Natural = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Natural Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Natural Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Text = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Text Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Text Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Rational Rational = Hs.ofY Hs.refl
  iLawfulEqTypConst .isEquality Rational Unit = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Bool = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Bytes = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Integer = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Natural = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Text = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Rational = Hs.ofN (λ ())
  iLawfulEqTypConst .isEquality Unit Unit = Hs.ofY Hs.refl

{-----------------------------------------------------------------------------
    Agda - Syntactic sugar
------------------------------------------------------------------------------}
_×_ : Typ → Typ → Typ
A × B = Two Product2 A B

_+_ : Typ → Typ → Typ
A + B = Two Sum2 A B
